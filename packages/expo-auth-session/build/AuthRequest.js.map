{"version":3,"file":"AuthRequest.js","sourceRoot":"","sources":["../src/AuthRequest.ts"],"names":[],"mappings":"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","sourcesContent":["import * as WebBrowser from 'expo-web-browser';\nimport invariant from 'invariant';\nimport { Linking, Platform } from 'react-native';\n\nimport { AuthSessionResult } from './AuthSession.types';\nimport { Discovery, fetchDiscoveryAsync } from './Discovery';\nimport { AuthResponseError } from './Errors';\nimport * as PKCE from './PKCE';\nimport * as QueryParams from './QueryParams';\nimport { getSessionUrlProvider } from './SessionUrlProvider';\nimport * as Storage from './Storage';\n\nconst sessionUrlProvider = getSessionUrlProvider();\n\nlet _authLock: boolean = false;\n\nexport enum CodeChallengeMethod {\n  S256 = 'S256',\n  Plain = 'plain',\n}\n\n/**\n * The client informs the authorization server of the\n * desired grant type by using the a response type.\n *\n * https://tools.ietf.org/html/rfc6749#section-3.1.1\n */\nexport enum ResponseType {\n  /**\n   * For requesting an authorization code as described by [Section 4.1.1](https://tools.ietf.org/html/rfc6749#section-4.1.1).\n   */\n  Code = 'code',\n  /**\n   * for requesting an access token (implicit grant) as described by [Section 4.2.1](https://tools.ietf.org/html/rfc6749#section-4.2.1).\n   */\n  Token = 'token',\n}\n\nexport type AuthRequestPromptOptions = {\n  url?: string;\n  useProxy?: boolean;\n  showInRecents?: boolean;\n  useRedirect?: boolean;\n};\n\nexport interface AuthRequestConfig {\n  responseType: ResponseType;\n  clientId: string;\n  /**\n   * https://tools.ietf.org/html/rfc6749#section-3.1.2\n   */\n  redirectUri: string;\n  scopes: string[];\n  clientSecret?: string;\n  codeChallengeMethod: CodeChallengeMethod;\n  codeChallenge?: string;\n  state?: string;\n  extraParams?: Record<string, string>;\n  usePKCE?: boolean;\n  discovery?: Discovery;\n  issuer?: string;\n}\n\nexport type AuthResponse = {\n  code: string;\n  state: string;\n};\n\n/**\n * Represents the authorization request.\n * For more information look at\n * https://tools.ietf.org/html/rfc6749#section-4.1.1\n */\nexport class AuthRequest {\n  static async buildAsync(config: AuthRequestConfig): Promise<AuthRequest> {\n    const request = new AuthRequest(config);\n    await request.buildUrlAsync();\n    return request;\n  }\n\n  responseType: ResponseType;\n  clientId: string;\n  redirectUri: string;\n  scopes: string[];\n  clientSecret?: string;\n  extraParams: Record<string, string>;\n  usePKCE?: boolean;\n  codeVerifier?: string;\n  codeChallenge?: string;\n  codeChallengeMethod: CodeChallengeMethod;\n  url: string | null = null;\n  /**\n   * Used for protection against [Cross-Site Request Forgery](https://tools.ietf.org/html/rfc6749#section-10.12).\n   */\n  state: Promise<string> | string;\n  private issuer?: string;\n  discovery?: Discovery;\n\n  constructor(request: AuthRequestConfig) {\n    this.responseType = request.responseType ?? ResponseType.Code;\n    this.clientId = request.clientId;\n    this.redirectUri = request.redirectUri;\n    this.scopes = request.scopes;\n    this.clientSecret = request.clientSecret;\n    this.state = request.state ?? PKCE.generateRandomAsync(10);\n    this.extraParams = request.extraParams ?? {};\n    this.codeChallengeMethod = request.codeChallengeMethod ?? CodeChallengeMethod.S256;\n    // PKCE defaults to true\n    this.usePKCE = request.usePKCE ?? true;\n    this.discovery = request.discovery;\n    this.issuer = request.issuer;\n\n    invariant(\n      this.redirectUri,\n      `\\`AuthRequest\\` requires a valid \\`redirectUri\\`. Ex: ${Platform.select({\n        web: 'https://yourwebsite.com/',\n        default: 'com.your.app:/oauthredirect',\n      })}`\n    );\n  }\n\n  public async getAuthRequestConfigAsync(): Promise<AuthRequestConfig> {\n    if (this.usePKCE) {\n      await this.ensureCodeIsSetupAsync();\n    }\n\n    return {\n      issuer: this.issuer,\n      discovery: await this.getDiscoveryAsync(),\n      responseType: this.responseType,\n      clientId: this.clientId,\n      redirectUri: this.redirectUri,\n      scopes: this.scopes,\n      clientSecret: this.clientSecret,\n      codeChallenge: this.codeChallenge,\n      codeChallengeMethod: this.codeChallengeMethod,\n      state: await this.getStateAsync(),\n      extraParams: this.extraParams,\n      usePKCE: this.usePKCE,\n    };\n  }\n\n  public async promptAsync({\n    url,\n    ...options\n  }: AuthRequestPromptOptions): Promise<AuthSessionResult> {\n    // Reuse the preloaded url\n    if (!(url ?? this.url)) {\n      return this.promptAsync({\n        ...options,\n        url: this.url ?? (await this.buildUrlAsync()),\n      });\n    }\n\n    // Prevent accidentally starting to an empty url\n    if (!url) {\n      throw new Error(\n        'No authUrl provided to AuthSession.startAsync. An authUrl is required -- it points to the page where the user will be able to sign in.'\n      );\n    }\n\n    let startUrl: string = url;\n    let returnUrl: string = this.redirectUri;\n    if (options.useProxy) {\n      returnUrl = sessionUrlProvider.getDefaultReturnUrl();\n      startUrl = sessionUrlProvider.getStartUrl(url, returnUrl);\n    }\n    if (options.useRedirect && Platform.OS === 'web') {\n      // Clear any prior auth request\n      await this.deletePendingAuthRequestAsync();\n      // Store the current discovery so we know which auth method is currently in progress\n      await Storage.setItemAsync(\n        getDiscoveryStorageKey(),\n        getDiscoveryId(await this.getDiscoveryAsync())\n      );\n      // Cache the current auth request for rehydration when the page returns.\n      await this.cacheAsync();\n      // @ts-ignore: The page will change and the return value won't be used\n      return Promise.resolve(window.location.assign(startUrl));\n    }\n\n    // Prevent multiple sessions from running at the same time, WebBrowser doesn't\n    // support it this makes the behavior predictable.\n    if (_authLock) {\n      if (__DEV__) {\n        console.warn(\n          'Attempted to call AuthSession.startAsync multiple times while already active. Only one AuthSession can be active at any given time.'\n        );\n      }\n\n      return { type: 'locked' };\n    }\n\n    // About to start session, set lock\n    _authLock = true;\n\n    let result: WebBrowser.WebBrowserAuthSessionResult;\n    try {\n      result = await WebBrowser.openAuthSessionAsync(startUrl, returnUrl, {\n        showInRecents: options.showInRecents,\n      });\n    } finally {\n      _authLock = false;\n    }\n\n    if (result.type === 'opened') {\n      // This should never happen\n      throw new Error('An unexpected error occurred');\n    }\n    if (result.type !== 'success') {\n      return { type: result.type };\n    }\n\n    return await this.parseReturnUrlAsync(result.url);\n  }\n\n  async parseReturnUrlAsync(url: string): Promise<AuthSessionResult> {\n    const { params, errorCode } = QueryParams.getQueryParams(url);\n    const { state, error = errorCode } = params;\n    const shouldNotify = state === this.state;\n\n    if (Platform.OS === 'web') {\n      const discovery = await this.getDiscoveryAsync();\n      await deletePendingAuthRequestAsync(discovery);\n    }\n\n    if (!shouldNotify) {\n      throw new Error('Cached state and returned state do not match.');\n    } else if (error) {\n      return {\n        type: 'error',\n        errorCode,\n        error: new AuthResponseError({ error, ...params }),\n        url,\n        params,\n      };\n    }\n\n    return {\n      type: 'success',\n      errorCode,\n      error: null,\n      url,\n      params,\n    };\n  }\n\n  public async buildUrlAsync(): Promise<string> {\n    const request = await this.getAuthRequestConfigAsync();\n    if (!request.state) throw new Error('Cannot build request without a valid `state` loaded');\n\n    // build the query string\n    // coerce to any type for convenience\n    let params: Record<string, string> = {};\n    if (request.codeChallenge) {\n      params.code_challenge = request.codeChallenge;\n    }\n    if (request.codeChallengeMethod) {\n      params.code_challenge_method = request.codeChallengeMethod;\n    }\n    if (request.clientSecret) {\n      params.client_secret = request.clientSecret;\n    }\n\n    // copy over extra params\n    for (const extra in request.extraParams) {\n      if (extra in request.extraParams) {\n        params[extra] = request.extraParams[extra];\n      }\n    }\n\n    // These overwrite any extra params\n    params = {\n      ...params,\n      redirect_uri: request.redirectUri,\n      client_id: request.clientId,\n      response_type: request.responseType,\n      state: request.state,\n      scope: request.scopes.join(' '),\n    };\n\n    const query = QueryParams.buildQueryString(params);\n    const discovery = await this.getDiscoveryAsync();\n    this.url = `${discovery.authorizationEndpoint}?${query}`;\n    return this.url;\n  }\n\n  private async getStateAsync(): Promise<string> {\n    if (this.state instanceof Promise) this.state = await this.state;\n    return this.state;\n  }\n\n  public async getDiscoveryAsync(): Promise<Discovery> {\n    if (!this.discovery) {\n      if (this.issuer) {\n        this.discovery = await fetchDiscoveryAsync(this.issuer);\n      } else {\n        throw new Error(\n          'AuthRequest requires either a discovery or issuer but neither were provided.'\n        );\n      }\n    }\n    return this.discovery;\n  }\n\n  private async cacheAsync(): Promise<void> {\n    if (Platform.OS !== 'web') return;\n    const discovery = await this.getDiscoveryAsync();\n    const discoveryId = getDiscoveryId(discovery);\n    const storageKey = getStorageKey(discoveryId);\n    const existingHandle = await Storage.getItemAsync(storageKey);\n    // Don't overwrite cache\n    if (existingHandle) {\n      if (__DEV__) {\n        console.warn('Cannot start a new auth because another session is already in progress');\n      }\n      return;\n    }\n\n    // Ensure we load the full request before caching it\n    const requestJson = await this.getAuthRequestConfigAsync();\n\n    const handle = await PKCE.generateRandomAsync(10);\n\n    // before you make request, persist all request related data in local storage.\n    await Promise.all([\n      Storage.setItemAsync(storageKey, handle),\n      Storage.setItemAsync(authRequestStorageKey(discoveryId, handle), JSON.stringify(requestJson)),\n    ]);\n  }\n\n  async deletePendingAuthRequestAsync(): Promise<boolean> {\n    return deletePendingAuthRequestAsync(await this.getDiscoveryAsync());\n  }\n\n  private async ensureCodeIsSetupAsync(): Promise<void> {\n    if (this.codeVerifier) {\n      return;\n    }\n\n    // This method needs to be resolved like all other native methods.\n    const { codeVerifier, codeChallenge } = await PKCE.buildCodeAsync();\n\n    this.codeVerifier = codeVerifier;\n    this.codeChallenge = codeChallenge;\n  }\n}\n\nexport async function maybeCompleteAuthRequestAfterRedirectAsync(\n  urlString?: string\n): Promise<AuthSessionResult | null> {\n  if (Platform.OS !== 'web') return null;\n\n  if (!urlString) {\n    const currentUrl = await getCurrentUrlAsync();\n    if (!currentUrl) return null;\n    urlString = currentUrl;\n  }\n\n  const discoveryId = await Storage.getItemAsync(getDiscoveryStorageKey());\n  if (!discoveryId) return null;\n\n  const storageKey = getStorageKey(discoveryId);\n\n  const handle = await Storage.getItemAsync(storageKey);\n\n  // we have a pending request.\n  // fetch authorization request, and check state\n  const request = await maybeRehydratePendingAuthRequestAsync(discoveryId);\n  if (!urlString || !handle || !request) return null;\n\n  return await request.parseReturnUrlAsync(urlString);\n}\n\nasync function getCurrentUrlAsync(): Promise<string | null> {\n  return Platform.select<Promise<string | null>>({\n    web: Promise.resolve(window.location.href),\n    default: Linking.getInitialURL(),\n  });\n}\n\nasync function maybeRehydratePendingAuthRequestAsync(\n  discoveryId: string\n): Promise<AuthRequest | null> {\n  if (Platform.OS !== 'web') return null;\n\n  const storageKey = getStorageKey(discoveryId);\n\n  const handle = await Storage.getItemAsync(storageKey);\n  if (!handle) return null;\n\n  // we have a pending request.\n  // fetch authorization request, and check state\n  const item = await Storage.getItemAsync(authRequestStorageKey(discoveryId, handle));\n  return new AuthRequest(JSON.parse(item!));\n}\n\nasync function deletePendingAuthRequestAsync(\n  discovery: Pick<Discovery, 'authorizationEndpoint'>\n): Promise<boolean> {\n  if (Platform.OS !== 'web') return false;\n\n  const discoveryId = getDiscoveryId(discovery);\n  const storageKey = getStorageKey(discoveryId);\n  const handle = await Storage.getItemAsync(storageKey);\n  if (!handle) return false;\n\n  // cleanup state\n  await Promise.all([\n    Storage.deleteItemAsync(storageKey),\n    Storage.deleteItemAsync(getDiscoveryStorageKey()),\n    Storage.deleteItemAsync(authRequestStorageKey(discoveryId, handle)),\n  ]);\n  return true;\n}\n\nconst getDiscoveryId = ({\n  authorizationEndpoint,\n}: Pick<Discovery, 'authorizationEndpoint'>): string => {\n  return encodeURIComponent(authorizationEndpoint);\n};\nconst authRequestStorageKey = (discoveryId: string, handle: string): string =>\n  `${getStorageKey(discoveryId)}_${handle}`;\nconst getStorageKey = (discoveryId: string): string => `expo_auth_request_${discoveryId}`;\nconst getDiscoveryStorageKey = (): string => `expo_auth_request`;\n\nexport function clearQueryParams() {\n  if (Platform.OS !== 'web') return;\n  // Get the full URL.\n  const currURL = window.location.href;\n\n  const url = new window.URL(currURL);\n  // Append the pathname to the origin (i.e. without the search).\n  const nextUrl = url.origin + url.pathname;\n\n  // Here you pass the new URL extension you want to appear after the domains '/'. Note that the previous identifiers or \"query string\" will be replaced.\n  window.history.pushState({}, window.document.title, nextUrl);\n}\n"]}